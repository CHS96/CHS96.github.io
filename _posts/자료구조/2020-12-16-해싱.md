---
title:  "﻿해싱(Hashing)"
excerpt: "해싱(Hashing)을 알아보자!"

categories:
  - 자료구조
  
last_modified_at: 2020-12-16T18:35:00
---

대부분의 탐색 방법들은 탐색 키를 저장된 키값과 반복적으로 비교함으로써 탐색하고자 하는 항목에 접근한다. 이에 반해 해싱은 키값에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근하는 방법이다. 키값의 연산에 의해 직접 접근이 가능한 구조를 해시 테이블(Hash Table), 해시 테이블을 이용한 탐색을 해싱(Hashing)이라 한다.  

기존의 탐색 방법들은 정렬의 유무에 따라 O(N), O(log N)이 있었다. 해싱은 이론적으로 **O(1)**의 시간 안에 탐색이 가능한 방법이다. 

해싱에서는 자료를 저장하는 데 배열을 사용한다. 배열은 단점도 있지만 만약 원하는 항목이 저장된 위치를 알고 있다면 매우 빠르게 자료를 삽입하거나 꺼낼 수 있다. 그렇다면 배열의 인덱스를 어떻게 결정할까?  

해싱은 키를 해시 함수(Hash Function)를 통해 해시 주소(Hash Address)를 생성하고  이 해시 주소가 배열로 구현된 해시 테이블(Hash Table)의 인덱스가 된다.  

![해싱](https://user-images.githubusercontent.com/53072057/102298507-986e3080-3f94-11eb-93bd-90f3d9fae21d.JPG)  

일반적인 해시 함수는 탐색 키를 해시 테이블의 크기로 나누어서 그 나머지를 해시 테이블의 주소로 하는 것이다.  

![해싱1](https://user-images.githubusercontent.com/53072057/102298691-e84cf780-3f94-11eb-9505-df6f9d868fe8.JPG)  

하지만 M을 단순한 숫자로 하게 되면 똑같은 해시 주소를 가리키게 되면서 충돌이 발생할 수 있다. 예를 들어 1~100의 정수가 있는데 M이 10이라면 1, 11은 똑같은 ht[1]을 가리키게 된다. 충돌이 발생하게 되면  저장할 공간도 부족해지고 탐색 시간 또한 길어진다. 이를 해결하기 위해  M을 해시 테이블의 크기보다 **큰 소수**로 한다면 충돌을 방지할 수 있을 것이다.  

충돌을 해결하는 방법은 2가지가 있다.

1. **선형 조사법(Linear Probing)** : 충돌이 일어난  항목을 해시 테이블의 다른 위치에 저장한다.  
2. **체이닝(Chaining)** : 해시 테이블의 하나의 위치가 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경한다.  

선형 조사법은 만약 ht[k]에서 충돌이 일어난다면 그다음 주소인 ht[k+1]을 조사하여 빈 공간이면 저장하는 것이다. 만약 ht[k+1]도 이미 저장되어 있다면 계속해서 순차적으로 조사하는 방법이다. 선형 조사법은 탐색 시간이 많이 소요된다. 그 이유는 해시 주소가 다른 탐색 키하고도 비교해야 하는 데 있다. 만약 해시 주소가 같은 탐색 키들을 하나의 리스트로 묶어둔다면 불필요한 비교는 하지 않아도 될 것이다.  

체이닝은 이를 해결하기 위해 리스트를 고정된 리스트가 아니라 삽입과 삭제가 용이한 연결 리스트로 구현하는 것이다. ht[k]에서 충돌이 일어난다면 ht[k+1]를 확인하는 것이 아니라 새로운 노드를 생성하여 저장한다. 한 가지 결정해야 할 것은 연결 리스트의 어디에다 새로운 항목을 삽입하느냐 하는 것이다. 만약 탐색 키들의 중복을 허용한다면 연결 리스트의 처음에다 삽입하는 것이 가장 능률적이다. 만약 중복이 허용되지 않는다면 연결 리스트를 처음부터 탐색하여야 하므로 어차피 연결 리스트의 뒤로 가야 하고 여기에다 삽입하는 것이 자연스럽다.  


​


​ 
