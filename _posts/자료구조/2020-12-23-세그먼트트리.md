---
title:  "﻿세그먼트 트리(Segment Tree)"
excerpt: "세그먼트 트리(Segment Tree)를 알아보자!"

categories:
  - Blog
  
last_modified_at: 2020-12-23T18:35:00
---

이번에 배워볼 자료구조는 **세그먼트 트리(Segement Tree)**이다. 세그먼트 트리 역시 학부생 때 배우는 자료구조는 아니지만 최근 코딩 테스트에서 세그먼트 트리를 알고 있다면 조금 더 쉽게 해결할 수 있는 문제들이 나오고 있어서 한번 다뤄보려 한다. 세그먼트 트리는 이해하고 구현하는데 난이도가 상당히 있으며, 아직까지는 굳이 몰라도 된다고 생각하기 때문에 보다가 **이해가 안 된다면 과감하게 버리는 것을 추천**한다.  

세그먼트 트리는 트라이처럼 **트리를 활용한 자료구조**이다. 세그먼트 트리를 이해하기 위해 사용되는 구간 합 구하기라는 대표적인 문제가 있다. 이 문제를 통해 세그먼트 트리를 이해해 보자.  

구간 합 구하기 문제는 N 개의 숫자가 나열돼있을 때 a~b 구간의 데이터들의 합을 구하는 문제이다. 구간 합을 구하는 방법은 대표적으로 3가지가 존재한다.  

첫 번째는 단순하게 a부터 b까지 for 문을 돌리며 각 인덱스의 데이터를 전부 더해서 구하는 방법이다. 이 방법은 단순한 만큼 매번 **O(N)**의 시간만큼 연산해야 하기 때문에 상당히 비효율적인 방법이다.  

두 번째는 누적합을 미리 구해서 저장해놓고 필요할 때 사용하는 방법으로 다이나믹 프로그래밍 기법을 사용한다. 다음과 같이 1차원 배열을 선언하자.  

![seg1](https://user-images.githubusercontent.com/53072057/102952515-ae3ea100-4512-11eb-83c9-b084a3f25c72.JPG)  

우리는 다음과 같은 전처리 과정을 통해 dp[1]부터 dp[N]까지 **O(N)**의 시간으로 구할 수 있다.  

![seg2](https://user-images.githubusercontent.com/53072057/102952518-af6fce00-4512-11eb-8c4c-0270a3ffbd95.JPG)  

이후 a부터 b까지의 구간 합을 구한다면 dp[b] - dp[a - 1], **O(1)**의 시간 만에 구할 수 있게 된다.  

세 번째 방법은 지금부터 배울 세그먼트 트리를 이용하는 방법이다. 이미 누적합을 이용하는 방법을 통해 전처리 O(N) + 쿼리문 x O(1)의 시간 만에 구간 합을 구할 수 있는데 세그먼트 트리가 왜 필요할까? 다음과 같은 상황을 생각해 보자.   

​{1, 3, 5, 6, 8, 2, 6, 11}을 가지는 리스트가 있다고 하자. 우리는 누적합을 미리 구해서 빠른 시간 안에 구간 합을 구할 수 있었다. 그런데 만약 5번째 데이터인 8을 5로 변경한 후 3~5까지의 구간 합을 구한다면 어떻게 될까? 데이터가 변경이 되면 기존에 구해놓은 누적합 dp 배열을 사용할 수가 없다. 5번째 데이터가 변경되었기 때문에 dp[5]부터 dp[N]까지의 누적합을 새롭게 갱신해 줘야 한다. 매번 데이터의 값이 변경될 때마다 우리는 새롭게 누적합을 갱신해 줘야 하기 때문에 **O(N)**의 시간이 걸린다. 하지만 세그먼트 트리를 이용한다면 데이터의 값이 변경되어도 **O(log N)**의 시간 만에 갱신 및 구간 합을 구할 수 있다.  

트리의 특성상 모든 노드들을 트리의 높이, O(log N)의 시간 안에 접근할 수 있다. 이를 활용해서 데이터가 변경이 되어도 O(log N)의 시간 만에 데이터 및 데이터를 포함하는 구간 합을 업데이트해 주는 것이 세그먼트 트리의 특징이다. 세그먼트 트리의 형태는 다음과 같다. 최말단 노드에는 각 인덱스의 데이터를 삽입해 준다. 그 후 상위 노드로 올라갈 때마다 자식들의 누적합을 저장해놓는다.  

![seg3](https://user-images.githubusercontent.com/53072057/102952519-af6fce00-4512-11eb-92e9-1949f9832a2f.JPG)  

만약 1에서 6까지의 구간 합은 어떻게 구할까? 루트 노드에서 시작해서 내려가면서 노드에 저장된 누적합 구간이 구하고자 하는 구간에 속하면 더 이상 내려갈 필요 없이 저장된 값을 반환하면 된다. 좌측의 경우 1~4 구간이 구하고자 하는 구간에 속하기 때문에 더 이상 내려가지 않는다. 우측인 경우 5~8은 구하고자 하는 구간을 넘기 때문에 좌측으로 내려간다. 5~6 구간은 구하고자 하는 구간에 속하기 때문에 더 이상 내려갈 필요 없이 저장된 값을 반환한다. 우리는 O(log N) 시간 만에 구간 합을 구하였다. 사실 데이터의 변경이 없이 여러 번 구간 합을 구한다면 두 번째 방법인 누적합으로 O(1)의 시간 만에 구하는 것이 더 효율적이다.  

![seg4](https://user-images.githubusercontent.com/53072057/102952521-b0086480-4512-11eb-9f84-0a3774b8df7b.JPG)  

그렇다면 세그먼트 트리의 장점을 알기 위해 5번째 데이터인 8을 3으로 변경해보자. 누적합을 이용했다면 새롭게 dp 값을 갱신해 줘야 했기 때문에 O(N)의 시간이 들었다. 하지만 세그먼트 트리를 이용한다면 5를 포함하는 구간의 노드만 갱신해 주면 된다. 1~4 구간은 5구간을 포함하지 않기 때문에 갱신할 필요가 없다. 5구간을 포함하는 5구간, 5~6구간, 5~8구간, 1~8구간 순서로 4개의 노드만 갱신해 주면 된다. 트리의 특성상 O(log N)의 시간 만에 갱신할 수 있게 된다.  

![seg5](https://user-images.githubusercontent.com/53072057/102952522-b0a0fb00-4512-11eb-905a-95eba28514d8.JPG)  

대충 세그먼트 트리가 어떤 트리인지는 파악했을 것이다. 그렇다면 구현으로 넘어가 보자.  

세그먼트 트리를 구현하는 방법은 반복문을 이용한 **Bottom-Up 방식과 재귀 함수를 이용한 Top-Down 방식이 있다**. 반복문을 이용한 방법은 재귀 함수를 이용한 방법보다 구현하기가 쉽고 속도도 빠르다. 이에 반해 재귀 함수를 이용한 방법은 확장성이 뛰어나다는 장점이 있다. 따라서 상황에 따라 적절히 사용하는 것을 추천한다.  

먼저 반복문을 이용한 Bottom-Up 방식을 알아보자.  

세그먼트 트리를 보면 **완전 이진 트리의 형태**인 것을 알 수 있다. 이전에 배운 히프 자료구조를 한번 생각해 보자. 자식의 인덱스는 부모의 인덱스 * 2, 부모의 인덱스 * 2 + 1로 접근할 수 있었다. 반대로 부모의 인덱스는 자식의 인덱스 / 2로 접근할 수 있었다. 이를 활용해서 최말단 노드(Bottom)부터  최상단 노드(Up)까지 차례대로 값을 더해주면서 갱신해 주면 된다. 그렇다면 먼저 트리의 전체 구조를 설정해야 한다.  

먼저 최말단 노드의 인덱스는 어떻게 구할까? 루트 노드의 인덱스를 1로 둔다면 각 높이의 첫 번째 노드는 1, 2, 4, 8...의 형태로 2^(높이 - 1)인 것을 알 수가 있다. 따라서 최말단 노드의 첫 번째 인덱스는 다음과 같다.  

>$최말단\ 노드의\ 첫\ 번째\ 인덱스\ =\ 2^{트리의\ 높이\ -\ 1}$최말단 노드의 첫 번째 인덱스 = 2트리의 높이 − 1
