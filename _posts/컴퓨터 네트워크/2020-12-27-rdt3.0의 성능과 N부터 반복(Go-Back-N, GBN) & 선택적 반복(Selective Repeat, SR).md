---
title:  "rdt3.0의 성능과 N부터 반복(Go-Back-N, GBN) & 선택적 반복(Selective Repeat, SR)"
excerpt: "rdt3.0의 성능과 N부터 반복(Go-Back-N, GBN) & 선택적 반복(Selective Repeat, SR)을 알아보자!"

categories:
  - 컴퓨터 네트워크
  
last_modified_at: 2020-12-27T18:35:00
---

이전 글에서 rdt3.0이 기능적으로는 정확한 프로토콜이지만 성능이 오늘날의 고속 네트워크에선 만족스럽지 못하다고 언급하였다. 그 이유는 **전송-후-대기(Stop-and-Wait) 프로토콜**이기 때문이다. 그렇다면 왜 전송-후-대기 프로토콜이 성능이 좋지 못한지 한 번 알아보자.  

전송-후-대기의 단점은 송신자가 수신자에게 패킷을 한 번 보내면 송신자는 수신자의 반응을 확인하기 전까지는 다른 패킷을 수신자에게 보낼 수가 없다는 것이었다. 간단하게 그림으로 이해해 보자.  

A, B 두 종단 호스트가 존재한다고 하자. 두 종단 시스템 사이의 광속 왕복 전파 지연(RTT)은 대략 30 msec이다. 또한 1 Gbps(초당 10^9 비트) 전송률(R)을 가진 채널에 의해 연결되어 있다고 가정하자.  

![1](https://user-images.githubusercontent.com/53072057/103162473-77c79580-4834-11eb-93c9-63a0ece1f0c8.JPG)  

헤더 필드와 데이터를 모두 포함하여, 패킷당 1000바이트(8000비트)의 패킷 크기(L)를 가지고 1 Gbps 채널로 패킷을 실제로 전송하는데 필요한 시간은 다음과 같다.  

![2](https://user-images.githubusercontent.com/53072057/103162474-78f8c280-4834-11eb-850d-c9038c67df76.JPG)  

t = 0일 때 A에서 B에게 패킷을 하나 보낸다면 0.008 mesc의 시간이 흐르면 채널로 들어가게 될 것이다. 그다음 15 mesc 동안 채널을 통과하여 15.008 mesc의 시간 만에 패킷 하나가 B에게 수신될 것이다. ACK 패킷은 매우 작은 크기라고 가정하고 B는 수신하자마자 ACK 패킷을 A에게 보낸다. 그럼 최종적으로 A에게 ACK 패킷이 도달하는 시간은 30.008 mesc이다. 고작 8000 bits 크기의 패킷을 전송하는 데 30.008 mesc가 걸렸다는 것은 굉장히 비효율적이라는 것을 알 수 있다.  

이를 개선하기 위해서는 간단한 해결책이 있다. 패킷을 보낸 후 확인 응답을 기다리지 말고 계속해서 패킷을 보내는 방법이다. 이 기술을 **파이프라이닝(Pipelining)**이라고 한다. 파이프라이닝 방식은 신뢰적인 데이터 전송 프로토콜에서 다음과 같은 중요성을 가지고 있다.  

1. 순서 번호의 범위가 커져야 한다. 각각의 전송 중인 패킷(재전송은 고려하지 않음)은 유일한 순서 번호를 가져야 하고 거기에 전송 중이고 확인 응답이 안 된 여러 패킷이 있을지도 모르기 때문이다.  

2. 프로토콜의 송신 측과 수신 측은 한 패킷 이상을 버퍼링 해야 한다. 최소한 송신자는 전송되었으나 확인 응답 되지 않은 패킷을 버퍼링 해야 한다. 정확하게 수신된 패킷의 버퍼링은 수신자에서도 필요하다.  

3. 필요한 순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜이 손실 패킷과 손상 패킷 그리고 상당히 지연된 패킷들에 대해 응답하는 방법에 의존한다. 파이프라인 오류 회복의 두 가지 기본적인 접근 방법으로는 **N부터 반복(Go-Back-N, GBN)과 선택적 반복(Selective Repeat, SR)** 등이 있다.  

그렇다면 정지-후-대기 방식을 개선한 파이프라이닝의 대표적인 방식 2가지를 살펴보자.  

*1. N부터 반복(Go-Back-N, GBN)*  
GBN은 잘못된 패킷부터 N 개의 크기만큼 다시 재전송한다는 뜻이다. 재전송할 패킷의 개수를 N으로 제한하기 때문에 N을 윈도우 크기라고 부르며, GBN을 **슬라이딩 윈도우 프로토콜(Sliding-Window Protocol)**이라 부른다.  

![3](https://user-images.githubusercontent.com/53072057/103162475-78f8c280-4834-11eb-8a10-55b17c7b50a8.JPG)  

![4](https://user-images.githubusercontent.com/53072057/103162476-79915900-4834-11eb-8c82-9c99f9301f88.JPG)  

하지만 GBN 역시 단점이 존재한다. 왜냐하면 GBN은 N 개의 패킷 중 일부부만 손실되었어도 N 개의 패킷 모두를 재전송하기 때문이다. 또한, 수신 측에서 재전송이 필요한 경우는 패킷 손상 or 분실 이외에도 NAK 패킷을 받았을 경우, 지정한 타임아웃 내의 ACK 패킷 손실 등이 있었다. 이러한 경우에도 GBN은 N 개의 패킷을 재전송해야 하기 때문에 이는 상당히 비효율적이다.  

*2. 선택적 반복(Selective Repeat, SR)*  
N 개의 패킷을 재전송하는 GBN의 단점을 개선한 것이 바로 SR이다. SR은 GBN과 다르게 손상되거나 분실된 패킷들만 재전송하여 불필요한 재전송을 줄이는 방법이다. 이를 위해 SR은 수신 측 또한 별도의 윈도우를 가진다. 송신 측에서 N 개의 패킷을 전송하면 수신 측은 이를 버퍼에 저장한다. 만약 중간에 패킷이 분실되었다면 분실된 패킷에 대한 피드백을 송신 측에게 전송하고 송신 측은 분실된 패킷을 재전송한다. 수신 측의 윈도우가 꽉 차게 된다면 이를 상위 계층으로 전송하고 송신 측에게 다음 패킷을 전송해라고 요청한다. 다만, 주의해야 할 점은 송신 측과 수신 측간의 동기화 문제 때문에 SR의 윈도우 크기는 순서 번호 공간 크기의 절반보다 작거나 같아야 한다.  

![5](https://user-images.githubusercontent.com/53072057/103162478-7a29ef80-4834-11eb-9a0b-bba574402b2e.JPG)  

![6](https://user-images.githubusercontent.com/53072057/103162479-7a29ef80-4834-11eb-83b8-21e26eba59f7.JPG)  

SR은 GBN의 단점을 개선한 만큼 구조가 복잡하고 비용 또한 많이 든다. 이런 이유로 과거에는 GBN을 더 선호 시 하였지만 현대에는 성능을 우선시하기 때문에 상황에 맞게 적절히 활용하도록 하자.  