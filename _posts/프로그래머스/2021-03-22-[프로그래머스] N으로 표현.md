---
title:  "[프로그래머스] N으로 표현"

categories:
  - 프로그래머스
  
last_modified_at: 2021-03-22T18:35:00
---
 
[![N으로 표현](https://user-images.githubusercontent.com/53072057/111943905-ccb83680-8b19-11eb-8963-5878f114b69d.JPG)](https://programmers.co.kr/learn/courses/30/lessons/42895#)  

<h2>[ 문제풀이 ]</h2>  
dp를 활용하여 해결할 수 있는 문제이다. 왜 dp를 사용할 수 있는지를 알아보기 위해 N이 2인 경우를 한번 생각해 보자.  

N을 1번 사용하는 경우는 1가지이다.  

```java
2
```

그렇다면 N을 2번 사용해서 만들 수 있는 수는 뭐가 있을까? 다음과 같이 총 5가지의 종류가 있다.  

```java
2+2, 2-2, 2*2, 2/2
22
```

그렇다면 N을 3번 사용해서 만들 수 있는 수는 뭐가 있을까? 이는 다음과 같다.  

```java
2+2+2, 2-2-2, 2*2*2 2/2/2
2+22, 2-22, 2*22 2/22
2+2+2 2+2-2 2+2*2 2+2/2
2-2+2 2-2-2 2-2*2 2-2/2
2*2+2 2*2-2 2*2*2 2*2/2
2/2+2 2/2-2 2/2*2 2/2/2
22+2 22-2 22*2 22/2
222
```

뭔가 규칙이 보이지 않는가? 자세히보면 3번 사용한 조합은 1번 사용한 조합의 원소와 2번 사용한 조합의 원소들을 연산한 결과로 이루어진 것을 알 수 있다.  

```java
//1번과 2번의 조합
2+(2+2), 2-(2-2), 2*(2*2), 2/(2/2)
2+(22), 2-(22), 2*(22), 2/(22)
//2번과 1번의 조합
2+2+(2) 2+2-(2) 2+2*(2) 2+2/(2)
2-2+(2) 2-2-(2) 2-2*(2) 2-2/(2)
2*2+(2) 2*2-(2) 2*2*(2) 2*2/(2)
2/2+(2) 2/2-(2) 2/2*(2) 2/2/(2)
22+(2) 22-(2) 22*(2) 22/(2)
//사칙연산 없이 3번 사용해서 만든 수
222
```

즉, 이전의 값들을 사용해서 현재의 값을 계산할 수 있기 때문에 dp로 해결할 수 있다.  

dp 테이블을 다음과 같이 정의하자. 중복된 값들이 생길 수 있기 때문에 set을 사용해준다.  

```java
dp[i] : N을 i번 사용했을때 만들 수 있는 수의 set(중복 제거를 위해)
```

점화식은 다음과 같다.  

```java
dp[i] : (dp[1], dp[i-1]), (dp[2], dp[i-2]), ... , (dp[i-1], dp[1])의 원소들로 연산한 결과
```

N을 8번까지 사용하면서 연산한 결과가 number가 되는 최소 횟수를 찾아주면 된다.  

```java
import java.util.*;

class Solution {
	public int solution(int N, int number) {
		if (N == number) return 1;

		int M = 0;
		Set<Integer>[] dp = new HashSet[9];
		for (int i = 1; i <= 8; ++i) {
			dp[i] = new HashSet<>();
			//N, NN, NNN, ... , NNNNNNNN을 만들어줌
			M = M * 10 + N;
			dp[i].add(M);
		}
		//N을 2번~8번까지 사용하면서
		for (int i = 2; i <= 8; ++i) {
			//dp[i] : (dp[1], dp[i - 1]), (dp[2], dp[i - 2]), ... , (dp[i - 1], dp[1])의 조합
			for (int j = 1; j <= i - 1; ++j)  {
				for (int v1 : dp[j]) {
					for (int v2 : dp[i - j]) {
						dp[i].add(v1 + v2);
						dp[i].add(v1 - v2);
						dp[i].add(v1 * v2);
                        //분모가 0인 경우를 방지
						if (v2 != 0) dp[i].add(v1 / v2);
					}
				}
			}
			for (int v : dp[i]) {
				if (v == number) {
					return i;
				}
			}
		}
		return -1;
	}
}
```