---
title:  "페이지 교체 알고리즘"
excerpt: "페이지 교체 알고리즘을 알아보자!"

categories:
  - 운영체제
  
last_modified_at: 2021-02-10T18:35:00
---

주기억장치의 메모리 공간의 한계를 프로세스 전체가 메모리 내에 올라오지 않더라고 실행이 가능하도록 하는 가상기억장치 기법을 통해 해결한다고 하였다.  

가상기억장치는 프로그램 전체를 메모리에 적재하지 않는 대신, 초기에 필요한 것들만 미리 메모리에 할당하는 **요구 페이징(Demand Paging)**이라는 전략을 주로 사용한다.  

가상기억장치는 주로 **페이지** 단위로 관리한다.  

요구 페이징 전략을 통해 몇 개의 페이지가 메모리에 할당되고 프로그램을 실행한다고 가정하자. 프로그램 실행 시 필요한 페이지가 요구 페이징 전략을 통해 할당되지 않았을 수도 있다. 즉, 필요로 하는 페이지가 주기억장치에 없는 **페이지 부재(Page Fault)**가 발생할 수 있다.  

페이지 부재가 발생하게 되면, 원하는 페이지를 보조기억장치에서 가져와야 하는데 주기억장치가 꽉 찼다면 가져오는 페이지와 주기억장치에 할당된 페이지를 교체해야 한다.  

주기억장치에 할당된 페이지를 아무거나 교체한다면 비효율적일 것이다. 만약 페이지 A를 교체하였는데 바로 다음에 A를 필요로 하게 될 수도 있기 때문이다. 즉, 높은 성능을 위해 어떤 페이지를 선택하여 교체할 것인지를 결정하는 기법이 바로 **페이지 교체 알고리즘**이다.  

페이지 교체 알고리즘에는 FIFO, OPT, LRU, LFU, NUR, SCR 등이 존재한다. 하나씩 살펴보도록 하자.  

![페이지교체1](https://user-images.githubusercontent.com/53072057/107460398-6bf12200-6b9b-11eb-9bb8-6e88183cfb54.JPG)  

* 장점
	- 이해하기 쉽고, 프로그래밍 및 설계가 간단  
	
* 단점
	- 오래된 페이지가 무조건 불필요한 페이지가 아닐 수 있기 때문에 오히려 페이지 부재율을 높임  
	- Belady의 모순 : 페이지를 저장할 수 있는 페이지 프레임의 개수를 늘려도 오히려 페이지 부재가 더 많이 발생하는 모순이 존재  
	
![페이지교체2](https://user-images.githubusercontent.com/53072057/107460404-6d224f00-6b9b-11eb-92bf-f5de69b5cb8a.JPG)  

* 장점
	- 페이지 부재율이 가장 낮은 기법  
	
* 단점
	- 모든 프로세스의 메모리 참조 계획을 미리 파악할 수 없기 때문에 구현이 어려움  
	
![페이지교체3](https://user-images.githubusercontent.com/53072057/107460405-6dbae580-6b9b-11eb-9213-756b3a13a330.JPG)  

![페이지교체4](https://user-images.githubusercontent.com/53072057/107460407-6dbae580-6b9b-11eb-9b6c-854c4c9d6ebb.JPG)  

![페이지교체5](https://user-images.githubusercontent.com/53072057/107460408-6e537c00-6b9b-11eb-8822-d617049961f4.JPG)  

![페이지교체6](https://user-images.githubusercontent.com/53072057/107460410-6e537c00-6b9b-11eb-8b03-6f2e310aa86e.JPG)  

![페이지교체7](https://user-images.githubusercontent.com/53072057/107460412-6eec1280-6b9b-11eb-9a3b-573a482e2b41.JPG)  
